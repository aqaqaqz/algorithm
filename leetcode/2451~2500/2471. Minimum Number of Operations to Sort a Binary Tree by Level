/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
    vector<vector<TreeNode*>> treeList;
    unordered_map<int, TreeNode*> cache;
    void makePath(TreeNode* n, int level){
        if(n == nullptr) return;
        if(treeList.size() <= level)
            treeList.push_back(vector<TreeNode*>());
        
        treeList[level].push_back(n);
        cache[n->val] = n;

        makePath(n->left, level+1);
        makePath(n->right, level+1);
    }
public:
    int minimumOperations(TreeNode* root) {
        makePath(root, 0);

        int result = 0;
        for(vector<TreeNode*>& v : treeList){
            vector<int> ord;
            for(TreeNode* temp : v) ord.push_back(temp->val);
            sort(ord.begin(), ord.end());

            for(int i=0;i<v.size();i++){
                if(ord[i] == v[i]->val) continue;

                TreeNode* n1 = v[i];            // 현재 위치
                TreeNode* n2 = cache[ord[i]];   // 바꿔야할 위치

                int t = n1->val;
                n1->val = n2->val;
                n2->val = t;

                cache[n1->val] = n1;
                cache[n2->val] = n2;

                result++;
            }
        }
        
        return result;
    }
};